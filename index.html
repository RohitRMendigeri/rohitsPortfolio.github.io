<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>My Portfolio | Tech Enthusiast & Developer</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
    />
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <header>
      <div class="container">
        <div class="profile-container">
       
          <h1>Rohit Mendigeri</h1>
          <p class="typing-text">Computer Science Student</p>
          <div class="header-buttons">
            <a href="#contact" class="btn primary"
              >Let's Connect <i class="fas fa-arrow-right"></i
            ></a>
            <a href="#projects" class="btn secondary"
              >View Projects <i class="fas fa-code"></i
            ></a>
          </div>
        </div>
      </div>
    </header>

    <nav>
      <ul>
        <li><a href="#about" class="active">About Me</a></li>
        <li><a href="#education">Education</a></li>
        <li><a href="#projects">Projects</a></li>
        <li><a href="#skills">Skills</a></li>
        <li><a href="#contact">Contact</a></li>
      </ul>
    </nav>

    <main>
      <section id="about">
        <div class="container">
          <h2 class="section-title">About Me</h2>
          <div class="about-content">
            <div class="about-text">
              <h3>Hello, I'm Rohit!</h3>
              <p>
                I'm a Computer Science student with a passion for building
                innovative solutions. My work focuses on web development and
                machine learning, where I enjoy tackling challenges and
                creating meaningful impact through technology.    Currently pursuing B.E. in Computer Science and Engineering at
                KLE Technological University with a CGPA of 9.03. 
              </p>

            </div>
          </div>
        </div>
      </section>

      <section id="education" class="alt-bg">
        <div class="container">
          <h2 class="section-title">Education</h2>
          <div class="education">
            <div class="education-item">
              <div class="education-header">
                <h3>KLE Technological University</h3>
                <span class="cgpa">9.03 CGPA</span>
              </div>
              <p class="degree">B.E. in Computer Science and Engineering</p>
              <p>
                Coursework: Advanced algorithms, machine learning, data
                structures, computer vision, and software engineering practices.
              </p>
            </div>
          </div>
        </div>
      </section>

      <section id="projects">
        <div class="container">
          <h2 class="section-title">Projects & Experience</h2>
          <div class="projects-list">
            <div class="project-item">
              <div class="project-header">
                <h3>NVIDIA - Traffic Light Detection</h3>
                <span class="project-date"
                  >January 2025 - Present | Remote</span
                >
              </div>
              <div class="project-technologies">
                <span class="tech-tag">Computer Vision</span>
                <span class="tech-tag">YOLOX</span>
                <span class="tech-tag">Autonomous Driving</span>
              </div>
              <ul class="project-details">
                <li>
                  Developing a YOLOX-based traffic light detection framework for
                  autonomous driving
                </li>
                <li>
                  Analyzing Bosch Small Traffic Lights Dataset with augmentation
                  techniques
                </li>
                <li>
                  Conducting experiments to evaluate YOLOX performance under
                  diverse lighting conditions
                </li>
              </ul>
            </div>

            <div class="project-item">
              <div class="project-header">
                <h3>Multimodal Transformer Framework</h3>
              </div>
              <div class="project-technologies">
                <span class="tech-tag">Machine Learning</span>
                <span class="tech-tag">Computer Vision</span>
                <span class="tech-tag">Autonomous Systems</span>
              </div>
              <ul class="project-details">
                <li>
                  Developed a lightweight multimodal transformer framework for
                  estimating image differences in autonomous systems
                </li>
                <li>
                  Utilized the BDD100K dataset and Vision Transformer (ViT) for
                  feature extraction, integrating multimodal models like
                  OpenGVLab/Mini-InternVL-Chat-2B-V1-5
                </li>
                <li>
                  Designed the model for real-time analysis with low power
                  usage, ensuring scalability for autonomous driving and robotic
                  vision
                </li>
              </ul>
            </div>

            <div class="project-item">
              <div class="project-header">
                <h3>Online Course Enrollment System</h3>
                <span class="project-date">December 2024 - January 2025</span>
              </div>
              <div class="project-technologies">
                <span class="tech-tag">ReactJS</span>
                <span class="tech-tag">Express</span>
                <span class="tech-tag">MySQL</span>
                <span class="tech-tag">CSS</span>
              </div>
              <ul class="project-details">
                <li>
                  Developed an e-Course Enrollment System with user
                  authentication, credit management, and course recommendations
                </li>
                <li>
                  Built a responsive UI with React.js and optimized backend with
                  Node.js, Express.js, and MySQL
                </li>
                <li>
                  Implemented user-friendly interface that improved enrollment
                  completion rates by 35%
                </li>
              </ul>
            </div>

            <div class="project-item">
              <div class="project-header">
                <h3>Poetry Generation with GPT-Neo</h3>
              </div>
              <div class="project-technologies">
                <span class="tech-tag">Machine Learning</span>
                <span class="tech-tag">Deep Learning</span>
                <span class="tech-tag">NLP</span>
              </div>
              <ul class="project-details">
                <li>
                  Fine-tuned GPT-Neo for poetry generation, enhancing rhyme
                  structure and thematic consistency
                </li>
                <li>
                  Applied top-k sampling and temperature scaling to boost
                  fluency and creativity
                </li>
                <li>
                  Achieved a 12.77% improvement in semantic coherence over GPT-4
                </li>
              </ul>
            </div>
          </div>
        </div>
      </section>

      <section id="skills" class="alt-bg">
        <div class="container">
          <h2 class="section-title">Technical Skills</h2>
          <div class="skills-container">
            <div class="skill-category">
              <h3>Programming Languages</h3>
              <div class="skill-list">
                <span class="skill-item">C/C++ </span>
                <span class="skill-item">Python </span>
                <span class="skill-item">JavaScript</span>
                <span class="skill-item">HTML/CSS </span>
              </div>
            </div>

            <div class="skill-category">
              <h3>Frameworks & Libraries</h3>
              <div class="skill-list">
                <span class="skill-item">React.js</span>
                <span class="skill-item">Node.js</span>
                <span class="skill-item">Express.js</span>
                <span class="skill-item">PyTorch</span>
              </div>
            </div>

            <div class="skill-category">
              <h3>Databases & Tools</h3>
              <div class="skill-list">
                <span class="skill-item">MySQL</span>
                <span class="skill-item">MongoDB</span>
                <span class="skill-item">Git & GitHub</span>
                <span class="skill-item">Docker</span>
              </div>
            </div>
          </div>
        </div>
      </section>

      <section id="domain" class="alt-bg">
        <div class="container">
          <h2 class="section-title">üåê Domain: Google</h2>
          <div class="domain-overview">
            <div class="domain-card">
              <h3><i class="fab fa-google"></i>About Google</h3>
              <p>
                Google is a global tech leader that specializes in
                internet-related services and products, including:
              </p>
              <ul>
                <li>
                  <strong>Search Engines</strong> - World's most widely used
                  search technology
                </li>
                <li>
                  <strong>Cloud Computing</strong> - Scalable infrastructure and
                  services
                </li>
                <li>
                  <strong>Online Advertising</strong> - Digital marketing and
                  business intelligence
                </li>
                <li>
                  <strong>Operating Systems</strong> - Android, Chrome OS
                  powering billions of devices
                </li>
                <li>
                  <strong>Hardware</strong> - Pixel, Nest, Fitbit consumer
                  products
                </li>
                <li>
                  <strong>Artificial Intelligence & Machine Learning</strong> -
                  Advanced AI research and applications
                </li>
              </ul>
              <p>
                It operates under its parent company
                <strong>Alphabet Inc.</strong>, which houses a diverse set of
                sub-companies and technologies that are shaping the future.
              </p>
            </div>

            <div class="domain-card">
              <h3><i class="fas fa-heart"></i>Why Google?</h3>
              <p>
                Google embodies innovation, scale, and impact. Its engineering
                culture encourages experimentation and excellence, making it the
                ideal environment for someone like me who loves building
                intelligent systems and solving large-scale problems. Through
                this portfolio, I aim to demonstrate how my technical skills
                align with the challenges faced in various Google products.
              </p>
            </div>

            
          </div>
        </div>
      </section>

<section id="case-studies">
  <div class="container">
    <h2 class="section-title">Business Case Studies</h2>
    <div class="case-studies">
      <!-- Case Study 1: Search Autocomplete & IP Routing with Trie -->
      <div class="case-study">
        <h3>Case Study 1: Search Autocomplete & IP Routing with Trie</h3>
        <img
          src="assets/trie1.gif"
          alt="Animated visualization of a Trie (Prefix Tree) structure and its operations for prefix-based lookups"
          style="display: block; margin: 20px auto; max-width: 70%"
        />
        <h4>Real-Time Challenges</h4>
        <p>
          Systems like <strong>Google Search</strong>, <strong>YouTube</strong>, and <strong>Google DNS</strong> must provide:
        </p>
        <ul>
          <li><strong>Low-latency responses</strong></li>
          <li><strong>High accuracy</strong></li>
          <li><strong>Scalable prefix-based lookups</strong></li>
        </ul>
        <p>
          The underlying challenge: <strong>Quickly matching input prefixes to known queries or routes.</strong>
        </p>

        <h4>Core Data Structures</h4>
        <table class="complexity-table">
          <thead>
            <tr>
              <th>Use Case</th>
              <th>Data Structure</th>
              <th>Purpose</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Search</td>
              <td>Trie (Prefix Tree)</td>
              <td>Fast lookup of user query prefixes</td>
            </tr>
            <tr>
              <td>IP Routing</td>
              <td>Binary Trie (0/1)</td>
              <td>Match IPs to longest prefix route</td>
            </tr>
            <tr>
              <td>Ranking Results</td>
              <td>Min Heap / PriorityQ</td>
              <td>Top-K search suggestions</td>
            </tr>
            <tr>
              <td>Frequency Count</td>
              <td>Hash Map</td>
              <td>Store query popularity</td>
            </tr>
          </tbody>
        </table>

        <h4>Algorithm: Search Autocomplete</h4>
        <ol>
          <li><strong>Insert Queries:</strong></li>
          <ul>
            <li>Store user queries into a Trie.</li>
            <li>Track frequency using a Hash Map.</li>
          </ul>
          <li><strong>Suggest Completions:</strong></li>
          <ul>
            <li>Traverse Trie using input prefix.</li>
            <li>Use DFS to collect possible completions.</li>
            <li>Rank top-K suggestions via Min Heap.</li>
          </ul>
        </ol>

        <h4>Algorithm: IP Routing</h4>
        <ol>
          <li><strong>Insert Routes:</strong></li>
          <ul>
            <li>Convert IP prefixes (e.g., <code>192.168.0.0/16</code>) into binary.</li>
            <li>Insert into a Binary Trie, marking next-hop details.</li>
          </ul>
          <li><strong>Lookup IP Address:</strong></li>
          <ul>
            <li>Convert IP address to binary.</li>
            <li>Traverse Trie to find <strong>longest prefix match</strong>.</li>
          </ul>
        </ol>

        <h4>Time & Space Complexity</h4>
        <table class="complexity-table">
          <thead>
            <tr>
              <th>Operation</th>
              <th>Time Complexity</th>
              <th>Space Complexity</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Insert Query/Route</td>
              <td>O(N √ó L) / O(R √ó 32)</td>
              <td>O(N √ó L) / O(R √ó 32)</td>
            </tr>
            <tr>
              <td>Prefix Match (Search)</td>
              <td>O(P)</td>
              <td>O(K) (Top-K suggestions)</td>
            </tr>
            <tr>
              <td>Prefix Match (Routing)</td>
              <td>O(32) (IPv4 fixed)</td>
              <td>‚Äî</td>
            </tr>
            <tr>
              <td>Suggestion Retrieval</td>
              <td>O(M log K)</td>
              <td>‚Äî</td>
            </tr>
          </tbody>
        </table>
        <p>
          <em>Where:</em>
          <ul>
            <li>N = number of queries</li>
            <li>L = average query length</li>
            <li>R = number of routes</li>
            <li>P = input prefix length</li>
            <li>M = total suffixes</li>
            <li>K = number of suggestions</li>
          </ul>
        </p>

        <h4>Real-World Usage at Google</h4>
        <ul>
          <li><strong>Autocomplete:</strong> Google Search, Gmail, YouTube, Android Keyboard</li>
          <li><strong>Routing:</strong> Google DNS (8.8.8.8), CDNs, Cloud Routers</li>
        </ul>
        <p>
          <strong>Tries allow scalable and intelligent systems that feel instantaneous to the user.</strong>
        </p>
        <p><a href="https://github.com/RohitRMendigeri/rohitsPortfolio.github.io/blob/main/codes/trie.cpp" target="_blank">View Code Here</a>
</p>
      </div>

      <!-- Case Study 2: Route Optimization for Google Maps Navigation -->
      <div class="case-study">
        <h3>Case Study 2: Route Optimization for Google Maps Navigation</h3>
        <img
          src="assets/a_star.gif"
          alt="Animated visualization of A* Search algorithm finding the shortest path in a grid-based map"
          style="display: block; margin: 20px auto; max-width: 100%"
        />
        <h4>Challenge</h4>
        <p>
          Google Maps needs to compute <strong>shortest and fastest routes</strong> from millions of locations in real-time. The challenge lies in handling <strong>dynamic road conditions</strong> like traffic, closures, construction, and accidents ‚Äî all while keeping routing <strong>fast and accurate</strong>.
        </p>

        <h4>What is A* Search?</h4>
        <p>
          A* (A-Star) is a <strong>best-first search</strong> algorithm that finds the <strong>optimal path</strong> by balancing two factors:
        </p>
        <ul>
          <li><code>g(n)</code>: Actual cost from start node to current node</li>
          <li><code>h(n)</code>: Heuristic estimate of the cost from current node to goal</li>
        </ul>
        <p>
          It selects the path with the lowest <strong>f(n) = g(n) + h(n)</strong>.
        </p>
        <p>
          Compared to Dijkstra‚Äôs algorithm (which uses only <code>g(n)</code>), A* adds <strong>goal awareness</strong> through <code>h(n)</code>, making it more efficient in practice.
        </p>

        <h4>Heuristic Design in Real Systems</h4>
        <p>
          We can use <strong>informed heuristics</strong> that are both fast and realistic:
        </p>
        <ul>
          <li><strong>Straight-line distance</strong> (Haversine or Euclidean) ‚Äî base estimate.</li>
          <li><strong>Real-time traffic data</strong> ‚Äî adds weight to congested roads.</li>
          <li><strong>Road type priority</strong> ‚Äî highways are faster than city roads.</li>
          <li><strong>Time-of-day effects</strong> ‚Äî rush hour patterns, school zones.</li>
          <li><strong>Dynamic closures & incidents</strong> ‚Äî makes some edges temporarily unusable.</li>
        </ul>
        <p>
          These heuristics can help guiding the search efficiently while adapting to <strong>real-world constraints</strong>.
        </p>

        <h4>Time and Space Complexity</h4>
        <table class="complexity-table">
          <thead>
            <tr>
              <th>Operation</th>
              <th>Complexity</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Time (Worst Case)</td>
              <td>O(E) or O(V + E) log V (with Min Heap)</td>
            </tr>
            <tr>
              <td>Space</td>
              <td>O(V)</td>
            </tr>
          </tbody>
        </table>
        <p>
          <em>Where:</em> V = number of nodes (intersections), E = number of edges (roads)
        </p>
        <p>
          In practice, <strong>A*</strong> performs significantly faster due to the heuristic narrowing the search area.
        </p>
      </div>
        <!-- <p><a href="#" target="_blank">Trie code</a> -->
</p>

      <!-- Case Study 3: Accelerating Location-Based Search with KD-Tree -->
      <div class="case-study">
        <h3>Case Study 3: Accelerating Location-Based Search with KD-Tree</h3>
        <img
          src="assets/Kdtree_animation.gif"
          alt="Animated visualization of KD-Tree construction and nearest-neighbor search for spatial data"
          style="display: block; margin: 20px auto; max-width: 100%"
        />
        <h4>Problem</h4>
        <p>
          How can systems like <strong>Google Maps</strong>, <strong>Zomato</strong>, or <strong>CDNs</strong> quickly find the <strong>nearest location</strong> (restaurant, driver, server) based on a user's current position‚Äî<strong>in real time</strong>?
        </p>

        <h4>Solution: KD-Tree (K-Dimensional Tree)</h4>
        <p>
          A <strong>KD-Tree</strong> is a binary tree that organizes points in space (like latitude & longitude). It enables:
        </p>
        <ul>
          <li><strong>Fast nearest-neighbor searches</strong></li>
          <li"><strong>Efficient range queries</strong></li>
        </ul>
        <p>Perfect for geo-based systems.</p>

        <h4>How It Works</h4>
        <ol>
          <li><strong>Build Tree:</strong></li>
          <ul>
            <li>Recursively split points on alternating dimensions (lat, lon).</li>
            <li>Build takes <strong>O(N log N)</strong> time.</li>
          </ul>
          <li><strong>Search:</strong></li>
          <ul>
            <li>Traverse tree comparing user's location with nodes.</li>
            <li>Use a <strong>priority queue</strong> (Max Heap) to keep the top-K closest points.</li>
            <li>Prune distant branches for speed.</li>
          </ul>
        </ol>

        <h4>Time & Space Complexity</h4>
        <table class="complexity-table">
          <thead>
            <tr>
              <th>Operation</th>
              <th>Time (Avg)</th>
              <th>Space</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Build Tree</td>
              <td>O(N log N)</td>
              <td>O(N)</td>
            </tr>
            <tr>
              <td>Nearest Search</td>
              <td>O(log N)</td>
              <td>O(K)</td>
            </tr>
          </tbody>
        </table>
        <p>
          <em>Where:</em> N = number of locations, K = number of nearest results
        </p>
        <p>
          <strong>KD-Trees</strong> strike a great balance between speed and accuracy, making them essential for real-time, location-aware systems.
        </p>
          <p><a href="https://github.com/RohitRMendigeri/rohitsPortfolio.github.io/blob/main/codes/kdTree.cpp" target="_blank">View Code Here</a>
</p>
      </div>

      <!-- Case Study 4: Optimizing Storage and Bandwidth with Lossless Data Compression -->
      <div class="case-study">
        <h3>Case Study 4: Optimizing Storage and Bandwidth with Lossless Data Compression</h3>
        <img
          src="assets/Huffman_huff_demo.gif"
          alt="Animated visualization of Huffman Encoding process for compressing data"
          style="display: block; margin: 20px auto; max-width: 100%"
        />
        <h4>Challenge</h4>
        <p>
          Compress large volumes of data efficiently without losing any information.
        </p>

        <h4>Solution Overview: Huffman Encoding</h4>
        <p>
          A <strong>lossless compression algorithm</strong> that assigns shorter binary codes to frequent symbols and longer codes to rare ones, reducing overall data size.
        </p>

        <h4>Working</h4>
        <ol>
          <li>Count frequencies of symbols.</li>
          <li>Build a binary tree from least to most frequent symbols.</li>
          <li>Assign unique prefix codes by traversing the tree.</li>
          <li>Replace symbols with their binary codes for compression.</li>
        </ol>

        <h4>Real-World Usage at Google</h4>
        <ul>
          <li>Compressing images (JPEG in Google Photos)</li>
          <li>Audio compression in YouTube Music</li>
          <li>HTTP/2 header compression in Google Chrome</li>
        </ul>
          <p><a href="https://github.com/RohitRMendigeri/rohitsPortfolio.github.io/blob/main/codes/huffman.cpp" target="_blank">View Code Here</a>
</p>
      </div>

      <!-- Case Study 5: Instantaneous Time-Series Analysis for Monitoring and Analytics -->
      <div class="case-study">
        <h3>Case Study 5: Instantaneous Time-Series Analysis for Monitoring and Analytics</h3>
        <img
          src="assets/segmentTree.gif"
          alt="Animated visualization of Segment Tree construction and range query operations"
          style="display: block; margin: 20px auto; max-width: 100%"
        />
        <h4>Challenge</h4>
        <p>
          Google systems like YouTube Analytics and Cloud Monitoring must perform <strong>real-time range queries</strong> (sum, min, max) and updates on <strong>large time-series data</strong> efficiently.
        </p>

        <h4>Solution: Segment Trees</h4>
        <p>
          A <strong>Segment Tree</strong> is a binary tree that enables <strong>log-time range queries and updates</strong> by dividing data into manageable segments.
        </p>
        <p><strong>Use Cases:</strong></p>
        <ul>
          <li>Track views/clicks in a date range</li>
          <li>Detect anomalies in system metrics</li>
          <li>Real-time monitoring in dashboards</li>
        </ul>

        <h4>Core Data Structures</h4>
        <ul>
          <li><strong>Segment Tree Array:</strong> Compact binary representation</li>
          <li><strong>Lazy Propagation (Optional):</strong> For efficient range updates</li>
        </ul>

        <h4>How It Works</h4>
        <ul>
          <li><strong>Build:</strong> Recursively divide and compute values</li>
          <li><strong>Query [L, R]:</strong> Combine relevant segments</li>
          <li><strong>Update:</strong> Modify value and update parent nodes</li>
        </ul>

        <h4>Complexity</h4>
        <table class="complexity-table">
          <thead>
            <tr>
              <th>Operation</th>
              <th>Time</th>
              <th>Space</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Build</td>
              <td>O(N)</td>
              <td>O(2 √ó N)</td>
            </tr>
            <tr>
              <td>Query/Update</td>
              <td>O(log N)</td>
              <td>‚Äî</td>
            </tr>
          </tbody>
        </table>
          <p><a href="https://github.com/RohitRMendigeri/rohitsPortfolio.github.io/blob/main/codes/segment.cpp" target="_blank">View Code Here</a>
</p>
      </div>

      <!-- Case Study 6: Enabling Efficient Version Control with Queries -->
      <div class="case-study">
        <h3>Case Study 6: Enabling Efficient Version Control with Queries</h3>
        <img
          src="assets/persistentSegmentTree.png"
          alt="Diagram illustrating the structure and versioned updates of a Persistent Segment Tree"
          style="display: block; margin: 20px auto; max-width: 100%"
        />
        <h4>Challenge</h4>
        <p>
          Modern systems like <strong>Google Docs</strong>, <strong>Sheets</strong>, and <strong>BigQuery</strong> need to:
        </p>
        <ul>
          <li>Track data over time (version control)</li>
          <li>Support <strong>rollback/undo</strong></li>
          <li>Enable <strong>temporal queries</strong> ‚Äî all <strong>without duplicating</strong> entire datasets for each change</li>
        </ul>

        <h4>Solution: Persistent Segment Trees</h4>
        <p>
          A <strong>Persistent Segment Tree</strong> maintains multiple versions by copying only the <strong>modified nodes</strong> during updates, while <strong>sharing</strong> the rest of the structure. This allows efficient <strong>time-based querying and updates</strong>.
        </p>

        <h4>Algorithm</h4>
        <ul>
          <li>Each update creates a <strong>new root</strong> version.</li>
          <li>Previous versions remain intact.</li>
          <li>Ideal for querying across different versions.</li>
        </ul>

        <h4>Supported Operations</h4>
        <ul>
          <li><code>update(index, value, version)</code> ‚Üí creates a new version</li>
          <li><code>query(left, right, version)</code> ‚Üí returns result for a specific range in a version</li>
        </ul>

        <h4>Core Concepts</h4>
        <table class="complexity-table">
          <thead>
            <tr>
              <th>Concept</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Immutability</td>
              <td>Each version is a read-only snapshot</td>
            </tr>
            <tr>
              <td>Structural Sharing</td>
              <td>Only changed path is duplicated (rest reused)</td>
            </tr>
            <tr>
              <td>Functional Design</td>
              <td>Works well in distributed, stateless systems</td>
            </tr>
          </tbody>
        </table>

        <h4>Time & Space Complexity</h4>
        <table class="complexity-table">
          <thead>
            <tr>
              <th>Operation</th>
              <th>Time Complexity</th>
              <th>Space Complexity per Update</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Build Tree</td>
              <td>O(n)</td>
              <td>O(n)</td>
            </tr>
            <tr>
              <td>Update</td>
              <td>O(log n)</td>
              <td>O(log n)</td>
            </tr>
            <tr>
              <td>Range Query</td>
              <td>O(log n)</td>
              <td>O(1)</td>
            </tr>
            <tr>
              <td>Version Storage</td>
              <td>‚Äî</td>
              <td>O(log n) per version</td>
            </tr>
          </tbody>
        </table>
        <p>
          <em>Where:</em> n = number of elements in array or range
        </p>
        <p>
          Only <code>log n</code> new nodes are created per update, making it <strong>space-efficient</strong>.
        </p>

        <h4>Real-World Use Cases</h4>
        <ul>
          <li><strong>Google Docs:</strong> Maintain full edit history without copying entire documents</li>
          <li><strong>Google Sheets:</strong> Versioned formulas/data to support undo, audit logs</li>
          <li><strong>BigQuery:</strong> Enable historical range queries over time-partitioned data</li>
        </ul>
        <p>
          <strong>Persistent Segment Trees</strong> offer the perfect balance of <strong>versioning</strong>, <strong>efficiency</strong>, and <strong>query power</strong>, making them ideal for systems where <strong>history matters</strong>.
        </p>
          <p><a href="https://github.com/RohitRMendigeri/rohitsPortfolio.github.io/blob/main/codes/persistentSegmentTree.cpp" target="_blank">View Code Here</a>
</p>
      </div>

      <!-- Case Study 7: Optimizing Large-Scale Offline Range Queries for Analytics -->
      <div class="case-study">
        <h3>Case Study 7: Optimizing Large-Scale Offline Range Queries for Analytics</h3>
        <img
          src="assets/Mo's.png"
          alt="Diagram illustrating Mo's Algorithm for optimizing range queries"
          style="display: block; margin: 20px auto; max-width: 100%"
        />
        <h4>Challenge</h4>
        <p>
          In analytics systems like <strong>Google Trends</strong>, <strong>YouTube Analytics</strong>, or <strong>Ad Reporting</strong>, we often need to process <strong>many offline range queries</strong> like:
        </p>
        <ul>
          <li>Users watched videos between day 20 and day 40</li>
          <li>The most frequent query between time A and B</li>
        </ul>
        <p>
          Running each query separately can be slow‚Äîespecially on large datasets with tight performance needs.
        </p>

        <h4>Solution: Mo‚Äôs Algorithm</h4>
        <p>
          <strong>Mo‚Äôs Algorithm</strong> is an offline query optimization technique for <strong>range queries</strong>. It <strong>reorders</strong> the queries smartly to minimize redundant work when moving from one query to another.
        </p>

        <h4>Working</h4>
        <ol>
          <li>Divide array into blocks of size ‚àöN</li>
          <li>Sort queries by block of L, then R</li>
          <li>Initialize current window <code>[moLeft, moRight]</code></li>
          <li>For each query:</li>
          <ul>
            <li>Adjust <code>moLeft</code> and <code>moRight</code> using <code>add()</code> or <code>remove()</code></li>
            <li>Record the answer for that range</li>
          </ul>
        </ol>
        <p>
          Because adjacent queries change the window slightly, total cost is minimized.
        </p>

        <h4>Time & Space Complexity</h4>
        <table class="complexity-table">
          <thead>
            <tr>
              <th>Operation</th>
              <th>Time</th>
              <th>Space</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Preprocessing</td>
              <td>O(Q log Q)</td>
              <td>O(Q)</td>
            </tr>
            <tr>
              <td>Query Handling</td>
              <td>O((N + Q) ‚àöN)</td>
              <td>O(N)</td>
            </tr>
          </tbody>
        </table>
        <p><em>Where:</em> N = array size, Q = number of queries</p>

        <h4>Uses</h4>
        <ul>
          <li><strong>YouTube Analytics:</strong> Fast unique user queries over watch history</li>
          <li><strong>Ad Campaign Reporting:</strong> Frequency and count-based range stats</li>
          <li><strong>Google Trends:</strong> Offline computation of trends over time intervals</li>
          <li><strong>Search Query Logs:</strong> Efficient querying for frequency, count, or mode across ranges</li>
        </ul>
        <p>
          Mo‚Äôs Algorithm shines when we know all queries upfront and want <strong>speed without full recomputation</strong>‚Äîperfect for <strong>batch reporting</strong> and <strong>offline analytics</strong>.
        </p>
          <p><a href="https://github.com/RohitRMendigeri/rohitsPortfolio.github.io/blob/main/codes/mo.cpp" target="_blank">View Code Here</a>
</p>
      </div>

      <!-- Case Study 8: Efficient Tokenization in Large AI Models -->
      <div class="case-study">
        <h3>Case Study 8: Efficient Tokenization in Large AI Models</h3>
        <img
          src="assets/TrieTokenisation.png"
          alt="image of trie"
          style="display: block; margin: 20px auto; max-width: 70%"
        />
        <h4>AI Context Management Problem</h4>
        <p>
          Large language models (LLMs) like <strong>Gemini</strong> operate on <strong>tokens</strong>. The system must:
        </p>
        <ul>
          <li>Map input text to tokens efficiently</li>
          <li>Handle <strong>millions of vocabulary entries</strong></li>
          <li>Do so with <strong>minimal latency</strong> during inference</li>
        </ul>

        <h4>Core Data Structures</h4>
        <table class="complexity-table">
          <thead>
            <tr>
              <th>Component</th>
              <th>Data Structure</th>
              <th>Purpose</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Vocabulary Store</td>
              <td>Trie</td>
              <td>Fast prefix-based token matching</td>
            </tr>
            <tr>
              <td>Token Lookup</td>
              <td>Hash Map</td>
              <td>Mapping tokens to IDs/embeddings</td>
            </tr>
          </tbody>
        </table>

        <h4>Tokenization Algorithm</h4>
        <ol>
          <li><strong>Tokenize Input:</strong></li>
          <ul>
            <li>Read input string character-by-character</li>
            <li>Match the <strong>longest prefix</strong> in the Trie</li>
            <li>Convert to corresponding token ID (via hash map or array)</li>
          </ul>
        </ol>

        <h4>Time & Space Complexity</h4>
        <table class="complexity-table">
          <thead>
            <tr>
              <th>Operation</th>
              <th>Time Complexity</th>
              <th>Space Complexity</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Insert Vocabulary</td>
              <td>O(N √ó L)</td>
              <td>O(N √ó L)</td>
            </tr>
            <tr>
              <td>Token Lookup</td>
              <td>O(P)</td>
              <td>‚Äî</td>
            </tr>
          </tbody>
        </table>
        <p>
          <em>Where:</em>
          <ul>
            <li>N = number of tokens</li>
            <li>L = average token length</li>
            <li>P = prefix length in input string</li>
          </ul>
        </p>

        <h4>Managing the Context Window: Using a Ring Buffer</h4>
        <img
          src="assets/circularWindowBuffer.png"
          alt="Animated visualization of a Trie (Prefix Tree) structure and its operations for prefix-based lookups"
          style="display: block; margin: 20px auto; max-width: 70%"
        />
        <p>
          Transformers like those in <strong>Gemini</strong> or <strong>ChatGPT</strong> operate within a <strong>fixed-size context window</strong> (e.g., 8,192 tokens). This means:
        </p>
        <ul>
          <li>Oldest tokens must be discarded once the limit is reached</li>
          <li>Context must be efficiently updated without full reprocessing</li>
        </ul>
        <h5>Solution: Ring Buffer (Circular Buffer)</h5>
        <p>
          A <strong>ring buffer</strong> allows:
        </p>
        <ul>
          <li><strong>O(1)</strong> insertion and removal of tokens</li>
          <li>Efficient memory reuse (no shifting required)</li>
          <li>Seamless sliding of the context window as conversation grows</li>
        </ul>
        <h5>How it works:</h5>
        <ol>
          <li>The buffer holds the last <em>N</em> tokens (where <em>N</em> is the context limit).</li>
          <li>As new tokens are generated or input, they <strong>overwrite</strong> the oldest ones.</li>
          <li>This structure is ideal for <strong>chatbots</strong>, where ongoing conversation history must be preserved up to a limit.</li>
        </ol>
        <p>
          <strong>Combining Trie for tokenization and Ring Buffer for context control enables scalable, high-performance AI systems.</strong>
        </p>
          <p><a href="https://github.com/RohitRMendigeri/rohitsPortfolio.github.io/blob/main/codes/trie.cpp" target="_blank">Trie</a>
</p>
      </div>

      <!-- Case Study 9: Achieving Stable and Fair Matching in Resource Allocation -->
      <div class="case-study">
        <h3>Case Study 9: Achieving Stable and Fair Matching in Resource Allocation</h3>
        <img
          src="assets/stableMarriageProblem.gif"
          alt="Animated visualization of the Gale-Shapley Algorithm for stable matching"
          style="display: block; margin: 20px auto; max-width: 100%"
        />
        <h4>Challenge</h4>
        <p>
          Efficiently pair two groups based on mutual preferences, ensuring <strong>no two entities would prefer to deviate from their assigned match</strong>‚Äîi.e., no instability.
        </p>

        <h4>Solution: Gale‚ÄìShapley Algorithm (Deferred Acceptance)</h4>
        <p>
          This classic algorithm finds a <strong>stable matching</strong> in O(n¬≤) time:
        </p>
        <ol>
          <li>One group (e.g., candidates) proposes to its top-ranked options.</li>
          <li>The receiving group (e.g., companies) tentatively accepts the best proposal so far, rejecting others.</li>
          <li>Rejected candidates move to their next preferred choice.</li>
          <li>The process repeats until all are matched.</li>
        </ol>
        <ul>
          <li><strong>Guarantees Stability:</strong> No two individuals would swap and be happier.</li>
          <li><strong>Group-Optimality:</strong> The proposing group always gets its best possible stable match.</li>
        </ul>

        <h4>Time & Space Complexity</h4>
        <table class="complexity-table">
          <thead>
            <tr>
              <th>Operation</th>
              <th>Complexity</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Time (worst-case)</td>
              <td>O(n¬≤)</td>
            </tr>
            <tr>
              <td>Space</td>
              <td>O(n¬≤)</td>
            </tr>
          </tbody>
        </table>

        <h4>More Use Cases</h4>
        <ul>
          <li>Mentor-Mentee Matching in internal programs</li>
          <li>Cloud VM Scheduling based on workload and hardware affinity</li>
          <li>Local Ads Delivery matching businesses to ad slots with mutual preferences</li>
        </ul>
        <p>
          Stable Marriage is a powerful abstraction for <strong>fair, stable, and preference-driven assignments</strong> across diverse use cases.
        </p>
          <p><a href="https://github.com/RohitRMendigeri/rohitsPortfolio.github.io/blob/main/codes/stableMarriage.cpp" target="_blank">View Code Here</a>
</p>
      </div>

      <!-- Case Study 10: Finding the Optimal Path in Cost-Sensitive Systems -->
      <div class="case-study">
        <h3>Case Study 10: Finding the Optimal Path in Cost-Sensitive Systems</h3>
        <img
          src="assets/uniform_cost_search.png"
          alt="Diagram illustrating Uniform Cost Search for finding the lowest-cost path"
          style="display: block; margin: 20px auto; max-width: 100%"
        />
        <h4>Challenge</h4>
        <p>
          Efficiently finding the lowest-cost path or optimal solution in large-scale graphs with varying edge costs, such as optimizing network routing or task scheduling in Google‚Äôs infrastructure.
        </p>

        <h4>Solution: Uniform Cost Search</h4>
        <p>
          UCS is a graph search algorithm that always expands the node with the smallest cumulative cost first, guaranteeing the <strong>optimal path</strong> when edge costs vary.
        </p>
        <ul>
          <li>Uses a <strong>priority queue</strong> to select the next node with the least total cost so far.</li>
          <li>Continues exploring until the goal node is reached, ensuring the path found is the minimum-cost.</li>
          <li>Handles <strong>multiple goal nodes</strong> by stopping as soon as any goal is reached with the lowest cost.</li>
          <li>More suitable than BFS when edge costs are non-uniform.</li>
        </ul>

        <h4>Time & Space Complexity</h4>
        <table class="complexity-table">
          <thead>
            <tr>
              <th>Operation</th>
              <th>Complexity</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Time (worst-case)</td>
              <td>O(b^(1 + ‚åäC*/Œµ‚åã))</td>
            </tr>
            <tr>
              <td>Space</td>
              <td>O(b^(1 + ‚åäC*/Œµ‚åã))</td>
            </tr>
          </tbody>
        </table>
        <p>
          <em>Where:</em> b = branching factor, C* = cost of optimal solution, Œµ = minimum edge cost
        </p>

        <h4>Applications at Google</h4>
        <ul>
          <li><strong>Network Routing:</strong> Computing least-cost paths across Google‚Äôs global data center networks, balancing latency and bandwidth costs.</li>
          <li><strong>Task Scheduling:</strong> Ordering job executions in Google Cloud to minimize resource consumption and costs.</li>
          <li><strong>Google Maps Navigation:</strong> Finding cheapest routes considering dynamic costs like traffic and tolls.</li>
          <li><strong>Distributed Resource Allocation:</strong> Assigning compute/storage resources efficiently across clusters based on cost metrics.</li>
        </ul>
        <p>
          Uniform Cost Search enables <strong>optimal, cost-aware decision making</strong> across Google‚Äôs large-scale, weighted graph problems, especially where multiple potential goals exist.
        </p>
          <p><a href="https://github.com/RohitRMendigeri/rohitsPortfolio.github.io/blob/main/codes/uniformCostSearch.cpp" target="_blank">View Code Here</a>
</p>
      </div>

      <!-- Case Study 11: A Foundation for Security: Enabling Cryptography and Data Integrity -->
      <div class="case-study">
        <h3>Case Study 11: A Foundation for Security: Enabling Cryptography and Data Integrity</h3>
        <h4>Challenge</h4>
        <p>
          Google requires <strong>efficient modular arithmetic</strong> operations for cryptography, data integrity, and distributed systems, where modular division is needed but direct division is not possible.
        </p>

        <h4>Solution: Modular Multiplicative Inverse (MMI)</h4>
        <p>
          MMI computes the inverse of an integer <strong>a</strong> modulo <strong>m</strong>, finding <strong>x</strong> such that: (a √ó x) ‚â° 1 (mod m)
        </p>
        <p>This enables modular division critical for:</p>
        <ul>
          <li><strong>Cryptographic protocols:</strong> RSA, ECC for secure communication</li>
          <li><strong>Error detection and correction:</strong> Checksums and hashing</li>
          <li><strong>Consistent hashing:</strong> Load balancing in distributed storage</li>
        </ul>
        <p>Common methods to compute MMI:</p>
        <ul>
          <li>Extended Euclidean Algorithm (efficient and general)</li>
          <li>Fermat's Little Theorem (when modulus is prime)</li>
        </ul>

        <h4>Time & Space Complexity</h4>
        <table class="complexity-table">
          <thead>
            <tr>
              <th>Operation</th>
              <th>Complexity</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Extended Euclidean Algo</td>
              <td>O(log m)</td>
            </tr>
            <tr>
              <td>Fermat's Little Theorem</td>
              <td>O(log m)</td>
            </tr>
          </tbody>
        </table>

        <h4>Applications at Google</h4>
        <ul>
          <li><strong>Encryption & Decryption:</strong> Secure data transmission between Google services.</li>
          <li><strong>Integrity Checks:</strong> Hash-based authentication and error correction.</li>
          <li><strong>Distributed Systems:</strong> Efficient and balanced resource allocation using consistent hashing.</li>
        </ul>
        <p>
          MMI is a fundamental building block enabling <strong>secure, efficient, and reliable modular arithmetic</strong> in Google's large-scale systems.
        </p>
          <p><a href="https://github.com/RohitRMendigeri/rohitsPortfolio.github.io/blob/main/codes/fermatsLittle.cpp" target="_blank">View Code Here</a>
</p>
      </div>

      <!-- Case Study 12: Enabling Real-Time Sorted Access in Distributed Databases -->
      <div class="case-study">
        <h3>Case Study 12: Enabling Real-Time Sorted Access in Distributed Databases</h3>
        <img
          src="assets/skiplist.gif"
          alt="Animated visualization of Skip List structure and operations for ordered data access"
          style="display: block; margin: 20px auto; max-width: 100%"
        />
        <h4>Problem: Maintaining Ordered Data with Fast Range Access</h4>
        <p>
          Systems like <strong>Bigtable</strong>, <strong>Cloud Spanner</strong>, and <strong>LevelDB</strong> must handle:
        </p>
        <ul>
          <li><strong>Massive dynamic datasets</strong></li>
          <li>Frequent <strong>inserts/deletes</strong></li>
          <li>Fast <strong>range scans</strong> and <strong>point lookups</strong></li>
          <li>With <strong>low latency</strong> and <strong>high concurrency</strong></li>
        </ul>
        <p>
          Traditional balanced trees (e.g., AVL, Red-Black) are <strong>hard to scale</strong> across threads and machines due to complex rotations and locking.
        </p>

        <h4>Solution: Skip List</h4>
        <p>
          A <strong>Skip List</strong> is a probabilistic data structure that behaves like a multi-level linked list. It offers:
        </p>
        <ul>
          <li>Data is stored in sorted order across multiple linked list levels.</li>
          <li>Nodes are randomly promoted to higher levels to balance the structure without complex rotations.</li>
          <li>Searches start from the highest level and drop down, skipping many elements for speed.</li>
        </ul>

        <h4>How It Works</h4>
        <ul>
          <li>Each node may appear in multiple ‚Äúlevels‚Äù (randomly promoted)</li>
          <li>Higher levels act as <strong>express lanes</strong> for faster traversal</li>
          <li>Start search from the top, move forward until passed target, then drop down</li>
        </ul>

        <h4>Real-World Use Case: Google Bigtable‚Äôs Internal Index</h4>
        <p>
          Google Bigtable stores data in <strong>sorted key-value pairs</strong>. To:
        </p>
        <ul>
          <li><strong>Insert rows in sorted order</strong></li>
          <li><strong>Query ranges of rows</strong></li>
          <li><strong>Delete outdated entries efficiently</strong></li>
        </ul>
        <p>
          Skip Lists can be used for <strong>in-memory indexing (MemTable)</strong>.
        </p>

        <h4>Time Complexity (Average)</h4>
        <table class="complexity-table">
          <thead>
            <tr>
              <th>Operation</th>
              <th>Time Complexity</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Search</td>
              <td>O(log n)</td>
            </tr>
            <tr>
              <td>Insert</td>
              <td>O(log n)</td>
            </tr>
            <tr>
              <td>Delete</td>
              <td>O(log n)</td>
            </tr>
          </tbody>
        </table>
        <p>
          Insertions and deletions don‚Äôt require rebalancing. Randomization replaces structural complexity.
        </p>
        <p>
          <strong>Skip Lists</strong> strike a perfect balance between simplicity and performance‚Äîpowering real-time, ordered access across Google‚Äôs large-scale storage engines.
        </p>
          <p><a href="https://github.com/RohitRMendigeri/rohitsPortfolio.github.io/blob/main/codes/skiplist.cpp" target="_blank">View Code Here</a>
</p>
      </div>

      <!-- Case Study 13: Real-Time Spam Detection in Gmail -->
      <div class="case-study">
        <h3>Case Study 13: Real-Time Spam Detection in Gmail</h3>
        <img
          src="assets/slidingwindowGmail.gif"
          alt="Animated visualization of the Sliding Window technique for processing data streams"
          style="display: block; margin: 20px auto; max-width: 100%"
        />
        <h4>The Challenge</h4>
        <p>
          Gmail must detect spam <strong>immediately</strong> upon email arrival. With billions of emails sent daily, reprocessing entire datasets is too expensive.
        </p>
        <p>
          We need an efficient method to extract insights from <strong>continuous data streams</strong>.
        </p>

        <h4>Solution: Sliding Window Algorithm</h4>
        <p>
          The <strong>Sliding Window</strong> technique allows us to process only the <strong>most recent subset</strong> of data efficiently.
        </p>
        <ul>
          <li><strong>Time Efficiency:</strong> Only new data is processed as the window slides.</li>
          <li><strong>Space Efficiency:</strong> Only the current window‚Äôs data is stored in memory.</li>
        </ul>
        <p>
          <em>Where k is window size, m is length of the pattern, n is length of the text, z is total output size.</em>
        </p>

        <h4>Proposed Applications in Gmail</h4>
        <h5>1. Spam Phrase Detection</h5>
        <ul>
          <li><strong>Rabin-Karp Algorithm:</strong> Rolling hash enables fast matching of phrases inside the window.</li>
          <li><strong>Aho-Corasick Algorithm:</strong> Detects multiple spam phrases simultaneously in linear time.</li>
        </ul>
        <h5>2. Sender Behavior Monitoring</h5>
        <ul>
          <li><strong>Time-based sliding window</strong> can track email sending rates.</li>
          <li><strong>Token Bucket algorithm</strong> can allow brief bursts but flag sustained high-volume behavior.</li>
        </ul>

        <h4>Time & Space Complexity</h4>
        <table class="complexity-table">
          <thead>
            <tr>
              <th>Operation</th>
              <th>Time Complexity</th>
              <th>Space Complexity</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Window Slide Update</td>
              <td>O(1)</td>
              <td>O(k)</td>
            </tr>
            <tr>
              <td>Phrase Matching (Rabin-Karp)</td>
              <td>O(m + n)</td>
              <td>O(1)</td>
            </tr>
            <tr>
              <td>Multi-pattern Matching (Aho-Corasick)</td>
              <td>O(n + z)</td>
              <td>O(m¬∑k)</td>
            </tr>
          </tbody>
        </table>

        <h4>Supporting Data Structures</h4>
        <table class="complexity-table">
          <thead>
            <tr>
              <th>Data Structure</th>
              <th>Use Case</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>Deque</code></td>
              <td>Tracks max/min values, e.g., spike in send rate</td>
            </tr>
            <tr>
              <td><code>HashMap</code></td>
              <td>Stores frequency of phrases or sender activity</td>
            </tr>
            <tr>
              <td><code>Rolling Hash</code></td>
              <td>Efficient comparison of phrases inside the content window</td>
            </tr>
          </tbody>
        </table>

        <h4>Final Impact</h4>
        <p>
          This approach enables <strong>real-time spam filtering</strong> without overloading Gmail‚Äôs systems, while maintaining user experience and system responsiveness.
        </p>
          <p><a href="https://github.com/RohitRMendigeri/rohitsPortfolio.github.io/blob/main/codes/slidingWindow.cpp" target="_blank">View Code Here</a>
</p>
      </div>

      <!-- Case Study 14: Enhancing Android App Update Integrity with Merkle Trees -->
      <div class="case-study">
        <h3>Case Study 14: Enhancing Android App Update Integrity with Merkle Trees</h3>

        <h4>Key Challenges</h4>
        <p>
          Google Play Store delivers large-scale app updates (APKs/AABs) to billions of Android devices. Ensuring <strong>security</strong>, <strong>efficiency</strong>, and <strong>data integrity</strong>‚Äîespecially on unreliable networks or against tampered APKs‚Äîis crucial.
        </p>
        <ul>
          <li><strong>Large File Sizes:</strong> APKs often exceed 100 MB.</li>
          <li><strong>Update Resumption:</strong> Failed downloads traditionally require restarting.</li>
          <li><strong>No Chunk-Level Verification:</strong> Full-file checksums can't detect partial tampering.</li>
          <li><strong>Tampered APKs:</strong> Sideloaded or hacked apps may include malicious code.</li>
          <li><strong>Efficient Patching:</strong> Users often have older app versions; downloading the entire new version is inefficient.</li>
        </ul>

        <h4>Solution: Merkle Tree-Based Integrity Verification</h4>
        <img
          src="assets/merkleTree.gif"
          alt="Animated visualization of a Trie (Prefix Tree) structure and its operations for prefix-based lookups"
          style="display: block; margin: 20px auto; max-width: 70%"
        />
        <p>
          Introducing Merkle Trees enables <strong>chunk-level verification and secure patching</strong> during updates.
        </p>
        <h5>Algorithm</h5>
        <ol>
          <li><strong>Chunking:</strong> APK/AAB is split into fixed-size blocks (e.g., 4 KB).</li>
          <li><strong>Leaf Hashing:</strong> Each chunk is hashed using SHA-256.</li>
          <li><strong>Tree Construction:</strong> Hashes are recursively combined up to a signed Merkle Root.</li>
          <li><strong>Verification:</strong></li>
          <ul>
            <li>Clients use Merkle Proofs to validate each chunk.</li>
            <li>If any chunk is corrupted or modified (e.g., via sideloading), validation fails.</li>
          </ul>
          <li><strong>Delta Updates:</strong></li>
          <ul>
            <li>Only changed chunks are downloaded (e.g., between app version 1.0 and 1.1).</li>
            <li>Verified using Merkle proofs, ensuring only correct, untampered blocks are accepted.</li>
          </ul>
        </ol>

        <h4>Benefits</h4>
        <ul>
          <li>Detects tampered APKs (even if modified offline)</li>
          <li>Secure resumption of interrupted downloads (helpful for larger data)</li>
          <li>Efficient updates by downloading only changed chunks</li>
          <li>Reduces bandwidth and load on Google's infrastructure</li>
          <li>Scales to billions of devices</li>
        </ul>

        <h4>Underlying Concepts</h4>
        <ul>
          <li><strong>Merkle Tree:</strong> Binary tree of SHA-256 hashes built from app chunks.</li>
          <li><strong>Merkle Proof:</strong> Enables client to verify individual chunk integrity.</li>
          <li><strong>Digital Signature:</strong> Authenticates the Merkle Root and prevents tampering.</li>
        </ul>

        <h4>Enhancements</h4>
        <p>
          By integrating Merkle Trees more deeply with delta update mechanisms, Google can further:
        </p>
        <ul>
          <li>Improve <strong>differential patching</strong> granularity</li>
          <li>Reduce unnecessary data transmission</li>
          <li>Catch <strong>any unauthorized modifications</strong>, even if a single byte is altered</li>
        </ul>

          <p><a href="https://github.com/RohitRMendigeri/rohitsPortfolio.github.io/blob/main/codes/merkleTree.py" target="_blank">View Code Here</a>
</p>
      </div>

      <!-- Case Study 15: Live Engagement Analytics in YouTube using Sliding Window -->
      <div class="case-study">
        <h3>Case Study 15: Live Engagement Analytics in YouTube using Sliding Window</h3>
        
        <h4>The Challenge</h4>
        <p>
          YouTube receives massive user engagement data every second. We need to process these streams in <strong>real time</strong> to support:
        </p>
        <ul>
          <li>Viewer drop-off analysis</li>
          <li>Peak interaction tracking</li>
          <li>Ad placement optimization</li>
        </ul>

        <h4>Solution: Sliding Window for Streaming Analytics</h4>
        <img
          src="assets/youtubeSlidingWindow.png"
          alt="Animated visualization of the Sliding Window technique for processing data streams"
          style="display: block; margin: 20px auto; max-width: 100%"
        />
        <p>
          By continuously moving a time window across live data, we can extract insights with minimal overhead.
        </p>
        <ul>
          <li><strong>Real-time feedback</strong></li>
          <li><strong>Low memory consumption</strong></li>
          <li><strong>Avoid full data reprocessing</strong></li>
        </ul>

        <h4>Applications in YouTube</h4>
        <h5>1. Watch-Time Drop Detection</h5>
        <ul>
          <li>Analyze <strong>engagement logs</strong> within a sliding window to detect where viewers stop watching.</li>
          <li>Flag timestamps like <code>00:45‚Äì01:15</code> as boring or disengaging.</li>
        </ul>
        <h5>2. Real-Time Engagement Monitoring</h5>
        <p>Use sliding windows to track:</p>
        <ul>
          <li><strong>Live peak viewer counts</strong></li>
          <li><strong>Burst in likes/subscribers</strong></li>
          <li><strong>Optimal ad display timing</strong></li>
          <li><strong>Spikes in comments/interactions</strong></li>
        </ul>

        <h4>Time & Space Complexity</h4>
        <table class="complexity-table">
          <thead>
            <tr>
              <th>Operation</th>
              <th>Time Complexity</th>
              <th>Space Complexity</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Engagement Window Slide Update</td>
              <td>O(1)</td>
              <td>O(k)</td>
            </tr>
            <tr>
              <td>Aggregate Metrics (sum, avg, etc)</td>
              <td>O(1) or O(log k)</td>
              <td>O(k)</td>
            </tr>
            <tr>
              <td>Spike/Peak Detection (e.g. via deque)</td>
              <td>O(1)</td>
              <td>O(k)</td>
            </tr>
          </tbody>
        </table>
        <p><em>Where k is the sliding window size (e.g., 60s of interactions).</em></p>

        <h4>Supporting Data Structures</h4>
        <table class="complexity-table">
          <thead>
            <tr>
              <th>Data Structure</th>
              <th>Use Case</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>Deque</code></td>
              <td>Efficient peak/min tracking within current window</td>
            </tr>
            <tr>
              <td><code>HashMap</code></td>
              <td>Aggregation and categorization of interaction types</td>
            </tr>
            <tr>
              <td><code>Rolling Hash</code></td>
              <td>Less relevant here, but can be used in video content fingerprinting</td>
            </tr>
          </tbody>
        </table>

        <h4>Final Impact</h4>
        <p>
          Sliding Window-based analysis empowers YouTube to <strong>adapt content delivery</strong> and <strong>enhance viewer experience</strong>, all while handling massive-scale, high-frequency data.
        </p>
          <p><a href="https://github.com/RohitRMendigeri/rohitsPortfolio.github.io/blob/main/codes/slidingWindow.cpp" target="_blank">View Code Here</a>
</p>
      </div>
    </div>
  </div>
</section>

      <h3>All the references are <a href="https://github.com/RohitRMendigeri/rohitsPortfolio.github.io/blob/main/references.md">here</a></h3>

      <section id="contact">
        <div class="container">
          <h2 class="section-title">Get in Touch</h2>
          <div class="contact-container">
            <div class="contact-info">
              <h3>Let's Connect</h3>
              <p>
                I'm always open to discussing new projects, creative ideas, or
                opportunities to be part of your vision.
              </p>
              <div class="contact-item">
                <i class="fas fa-envelope"></i>
                <span>rohitmendigeri@gmail.com</span>
              </div>
              <div class="contact-item">
                <i class="fas fa-map-marker-alt"></i>
                <span>Dharwad, Karnataka</span>
              </div>
            </div>
            <div class="contact-form">
              <h3>Send a Message</h3>
              <div class="form-group">
                <label for="name">Name</label>
                <input type="text" id="name" placeholder="Your Name" required />
              </div>
              <div class="form-group">
                <label for="email">Email</label>
                <input
                  type="email"
                  id="email"
                  placeholder="Your Email"
                  required
                />
              </div>
              <div class="form-group">
                <label for="message">Message</label>
                <textarea
                  id="message"
                  placeholder="Your Message"
                  required
                ></textarea>
              </div>
              <button type="submit" class="btn primary">
                Send Message <i class="fas fa-paper-plane"></i>
              </button>
            </div>
          </div>
        </div>
      </section>
    </main>

    <footer>
      <div class="container">
        <div class="social-links">
          <a
            href="https://in.linkedin.com/in/rohit-mendigeri-a31b122a9"
            target="_blank"
            ><i class="fab fa-linkedin"></i
          ></a>
          <a href="https://github.com/RohitRMendigeri" target="_blank"
            ><i class="fab fa-github"></i
          ></a>
          <a href="https://twitter.com" target="_blank"
            ><i class="fab fa-twitter"></i
          ></a>
        </div>
        <div class="footer-nav">
          <a href="#about">About</a>
          <a href="#projects">Projects</a>
          <a href="#skills">Skills</a>
          <a href="#contact">Contact</a>
        </div>
        <p>¬© 2025 Rohit Mendigeri. All rights reserved.</p>
      </div>
    </footer>
  </body>
</html>
